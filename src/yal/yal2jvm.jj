/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. yal2jvm.jj */
/*@egen*/options{
                         
               
}

PARSER_BEGIN(yal2jvm)

package yal;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.IOException;
import java.util.*;


/**
 * Main Class of the Compiler
 * It deals with Lexical, Syntactic and Semantic analysis all their errors.
 */
public class yal2jvm/*@bgen(jjtree)*/implements yal2jvmTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTyal2jvmState jjtree = new JJTyal2jvmState();

/*@egen*/
    public static int error_counter = 0;
    private static SimpleNode astRoot = null;
    /**
      * Main function. 
      * The program begins with a Lexical and Syntactic analysis, using a Context-Free Gramar, followed by the Semantic analysis.
      * Afterwards, it generates the code into Java bytecodes to a Jasmin file. 
     */
    public static void main(String args[]) throws ParseException, IOException {
        InputStream f = null;
        boolean showAst = false;
        boolean showSymbolTable = false;
        boolean generateJavaBytecodes = false;
        Scanner scanner = new Scanner(System.in);

        System.out.println("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
        System.out.println("#########################################");
        System.out.println("# Yal Compiler Project 2018 - Group G33 #");
        System.out.println("#########################################");

        if(args.length == 0){
            System.out.println("Proper Usage is: ./script filename \n Example: ./script yalExamples/MyFirstYalExamples/aval1.j");
            System.exit(0);
        }
        
        String fileName = args[0];

        System.out.println("Your file is " + fileName);

        try {
            f = new FileInputStream(/*"../yalExamples/" + */ "../" + fileName);
        }catch(FileNotFoundException e) {
            System.out.println(e.getMessage());
            return;
        }

        System.out.print("\nWould you like to see the AST?(1-Yes;0-No)  ");
        int astInput = scanner.nextInt();
        if(astInput == 1)
            showAst = true;
        else if(astInput != 0){
            System.out.println("Error in option!");
            return;
        }

        System.out.print("\nWould you like to see the Symbol Table?(1-Yes;0-No)  ");
        int symbolTableInput = scanner.nextInt();
        if(symbolTableInput == 1)
            showSymbolTable = true;
        else if(symbolTableInput != 0){
            System.out.println("Error in option!");
            return;
        }

        System.out.print("\nWould you like to generate Java Bytecodes in a jasmin file?(1-Yes;0-No)  ");
        int bytecodesInput = scanner.nextInt();
        if(bytecodesInput == 1)
            generateJavaBytecodes = true;
        else if(bytecodesInput != 0){
            System.out.println("Error in option!");
            return;
        }

        yal2jvm parser = new yal2jvm(f);
        astRoot = parser.Module();
        System.out.println("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
        System.out.println("File " + fileName + " parsed with " + error_counter + " syntactic errors\n");
        
        if(showAst){
            System.out.println("AST:");
            astRoot.dump("");
        }

        SymbolTable symbolTable = generateSymbolTable(astRoot);
        if(showSymbolTable)
            System.out.println("Symbol Table:\n" + symbolTable);

        System.out.println("File " + fileName + " parsed with " + symbolTable.semanticErrors + " semantic errors\n");


        if(generateJavaBytecodes)
            Bytecodes.generateJavaBytecodes(astRoot, symbolTable);
        
        System.out.println();
    }
}

PARSER_END(yal2jvm)

SKIP : {
    " "
    | "\t"
    | "\n"
    | "\r"
    | <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
    | <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

/* reserved words */
TOKEN : {
    <RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
    | <ADDSUB_OP: "+" | "-">
    | <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
    | <BITWISE_OP: "&" | "|" | "^">
    | <NOT_OP: "!">
    | <WHILE: "while">
    | <IF: "if">
    | <ELSE: "else">
    | <ASSIGN: "=">
    | <ASPA: "\"">
    | <LPAR: "(">
    | <RPAR: ")">
    | <VIRG: ",">
    | <PVIRG: ";">
    | <LCHAVETA: "{">
    | <RCHAVETA: "}">
    | <FUNCTION: "function">
    | <MODULE: "module">
    | <SIZE: "size">
}

TOKEN : {
    <INTEGER: (<DIGIT>)+>
    | <ID: <LETTER> (<LETTER> | <DIGIT>)*>
    | <#LETTER: ["$","A"-"Z","_","a"-"z"]>
    | <#DIGIT: ["0"-"9"]>
    | <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}

SimpleNode Module() : {/*@bgen(jjtree) Module */
                       ASTModule jjtn000 = new ASTModule(JJTMODULE);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}{/*@bgen(jjtree) Module */
    try {
/*@egen*/
    try{
        <MODULE> t=<ID>{jjtn000.jjtSetValue(t.image);} <LCHAVETA> (LOOKAHEAD(3) Declaration())* (Function())* <RCHAVETA>
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN MODULE " + e.toString());
        incErrorCounter();
        int[] kinds = {RCHAVETA, EOF};
        error_skipto(kinds);
    }/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Declaration() : {/*@bgen(jjtree) Declaration */
                      ASTDeclaration jjtn000 = new ASTDeclaration(JJTDECLARATION);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token t, t2;}{/*@bgen(jjtree) Declaration */
    try {
/*@egen*/

    t=<ID>{jjtn000.jjtSetValue(t.image);} ["[" "]" {jjtn000.jjtSetArrayType();}]
    [
    <ASSIGN>
    try{
        (("[" ArraySize() "]") {jjtn000.jjtSetArrayType();} | [<ADDSUB_OP>] t2=<INTEGER>{jjtn000.jjtSetIntType();})
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN DECLARATION " + e.toString());
        incErrorCounter();
        int[] kinds = {PVIRG};
        error_skipto(kinds);
    }
    ]
    try{
        <PVIRG>
    }
    catch(ParseException e){
        System.out.println("EXCEPTION IN DECLARATION " + e.toString());
        incErrorCounter();
        int[] kinds = {PVIRG};
        error_skipto(kinds);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


void Function() : {/*@bgen(jjtree) Function */
                   ASTFunction jjtn000 = new ASTFunction(JJTFUNCTION);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1, t2;}{/*@bgen(jjtree) Function */
    try {
/*@egen*/

    try{
        <FUNCTION>{jjtn000.jjtSetType(SimpleNode.Type.VOID);} [LOOKAHEAD(2) t2=<ID>{jjtn000.jjtSetSecValue(t2.image);jjtn000.jjtSetIntType();} ["[" "]"{jjtn000.jjtSetArrayType();}] <ASSIGN>] t1=<ID>{jjtn000.jjtSetValue(t1.image);}
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN FUNCTION " + e.toString());
        incErrorCounter();
        int[] kinds = {PVIRG, LCHAVETA, LPAR, ID};
        error_skipto(kinds);
    }

    try{
        <LPAR> [Varlist()] <RPAR>
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN FUNCTION " + e.toString());
        incErrorCounter();
        int[] kinds = {RPAR};
        error_skipto(kinds);
    }
    <LCHAVETA> Stmtlst() <RCHAVETA>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Varlist() : {/*@bgen(jjtree) Varlist */
  ASTVarlist jjtn000 = new ASTVarlist(JJTVARLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) Varlist */
    try {
/*@egen*/
    (Element()) ( <VIRG> Element() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ArrayElement() : {/*@bgen(jjtree) ArrayElement */
                       ASTArrayElement jjtn000 = new ASTArrayElement(JJTARRAYELEMENT);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) ArrayElement */
    try {
/*@egen*/
    t=<ID>{jjtn000.jjtSetValue(t.image);} "[" "]"/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Element() : {/*@bgen(jjtree) Element */
                  ASTElement jjtn000 = new ASTElement(JJTELEMENT);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Element */
    try {
/*@egen*/
    t=<ID>{jjtn000.jjtSetValue(t.image); jjtn000.jjtSetIntType();} ["[" "]"{jjtn000.jjtSetArrayType();}]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ScalarElement() : {/*@bgen(jjtree) ScalarElement */
                        ASTScalarElement jjtn000 = new ASTScalarElement(JJTSCALARELEMENT);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) ScalarElement */
    try {
/*@egen*/
    t=<ID>/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/{jjtn000.jjtSetValue(t.image);}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Stmtlst() : {/*@bgen(jjtree) Stmtlst */
  ASTStmtlst jjtn000 = new ASTStmtlst(JJTSTMTLST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Stmtlst */
    try {
/*@egen*/
    ( Stmt() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SpecialStmtlst()       : {}
{
    Stmtlst() <RCHAVETA>
}

void Stmt() : {/*@bgen(jjtree) Stmt */
  ASTStmt jjtn000 = new ASTStmt(JJTSTMT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Stmt */
    try {
/*@egen*/
    try{
        If() | While() | LOOKAHEAD(3) Assign() | Callstmt()
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN STMT " + e.toString());
        incErrorCounter();
        int[] kinds = {RPAR, PVIRG, LCHAVETA};
        error_skipto(kinds);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Assign() : {/*@bgen(jjtree) Assign */
  ASTAssign jjtn000 = new ASTAssign(JJTASSIGN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Assign */
    try {
/*@egen*/
    Lhs() <ASSIGN>
    try{
        Rhs() <PVIRG>
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN ASSIGN " + e.toString());
        incErrorCounter();
        int[] kinds = {PVIRG};
        error_skipto(kinds);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Lhs() : {/*@bgen(jjtree) Lhs */
              ASTLhs jjtn000 = new ASTLhs(JJTLHS);
              boolean jjtc000 = true;
              jjtree.openNodeScope(jjtn000);
/*@egen*/Token t, t1;}
{/*@bgen(jjtree) Lhs */
    try {
/*@egen*/
    t=<ID>{jjtn000.jjtSetValue(t.image);} ( ("[" Index() "]")|["." t1=<SIZE>{jjtn000.jjtSetSecValue(t1.image);}] )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Rhs() : {/*@bgen(jjtree) Rhs */
              ASTRhs jjtn000 = new ASTRhs(JJTRHS);
              boolean jjtc000 = true;
              jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Rhs */
    try {
/*@egen*/
    (Term() [(t=<ARITH_OP>| t=<BITWISE_OP> | t=<ADDSUB_OP>){jjtn000.jjtSetValue(t.image);}  Term()]) | "[" ArraySize() "]"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ArraySize() : {/*@bgen(jjtree) ArraySize */
                    ASTArraySize jjtn000 = new ASTArraySize(JJTARRAYSIZE);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) ArraySize */
    try {
/*@egen*/
    (ScalarAccess() | t=<INTEGER>{jjtn000.jjtSetValue(t.image);})/*@bgen(jjtree)*/
                                                                  {
                                                                    jjtree.closeNodeScope(jjtn000, true);
                                                                    jjtc000 = false;
                                                                  }
/*@egen*/ {jjtn000.jjtSetArrayType();}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Term() : {/*@bgen(jjtree) Term */
               ASTTerm jjtn000 = new ASTTerm(JJTTERM);
               boolean jjtc000 = true;
               jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1,t2,t3,t4;}
{/*@bgen(jjtree) Term */
    try {
/*@egen*/
    [t1=<ADDSUB_OP>{jjtn000.jjtSetOperation(t1.image);}] (t2=<INTEGER>/*@bgen(jjtree)*/
                                                                      {
                                                                        jjtree.closeNodeScope(jjtn000, true);
                                                                        jjtc000 = false;
                                                                      }
/*@egen*/{jjtn000.jjtSetValue(t2.image);jjtn000.jjtSetIntType();} | LOOKAHEAD(3) Call() | (t3=<ID>{jjtn000.jjtSetValue(t3.image);jjtn000.jjtSetAssignId(t3.image);} (("[" Index() "]")|(["." t4=<SIZE>{jjtn000.jjtSetSecValue(t4.image);jjtn000.jjtSetIntType();}]))))/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Exprtest() : {/*@bgen(jjtree) Exprtest */
                   ASTExprtest jjtn000 = new ASTExprtest(JJTEXPRTEST);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Exprtest */
    try {
/*@egen*/
    try{
        <LPAR> Lhs() t=<RELA_OP>{jjtn000.jjtSetOperation(t.image);} Rhs() <RPAR>
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN EXPRTEST " + e.toString());
        incErrorCounter();
        int[] kinds = {RPAR};
        error_skipto(kinds);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void While() : {/*@bgen(jjtree) While */
  ASTWhile jjtn000 = new ASTWhile(JJTWHILE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) While */
    try {
/*@egen*/
    <WHILE> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void If() : {/*@bgen(jjtree) If */
  ASTIf jjtn000 = new ASTIf(JJTIF);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) If */
    try {
/*@egen*/
    <IF> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA>

    try{
        [<ELSE> <LCHAVETA> Stmtlst() <RCHAVETA>]
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN ELSE " + e.toString());
        incErrorCounter();
        int[] kinds = {PVIRG};
        error_skipto(kinds);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Call() : {/*@bgen(jjtree) Call */
               ASTCall jjtn000 = new ASTCall(JJTCALL);
               boolean jjtc000 = true;
               jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1, t2;}
{/*@bgen(jjtree) Call */
    try {
/*@egen*/
    t1=<ID>{jjtn000.jjtSetValue(t1.image);jjtn000.jjtSetAssignId(t1.image);} ["." t2=<ID>{jjtn000.jjtSetSecValue(t2.image);jjtn000.jjtSetAssignId(t2.image);jjtn000.setAssignIdModule(t1.image);}] <LPAR>

    try{
        [ArgumentList()] <RPAR>
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN CALL " + e.toString());
        incErrorCounter();
        int[] kinds = {RCHAVETA, LCHAVETA, RPAR};
        int ret = error_skipto(kinds);
        if(ret == LCHAVETA){
            SpecialStmtlst();
        }
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Callstmt()       : {/*@bgen(jjtree) Call */
                         ASTCall jjtn000 = new ASTCall(JJTCALL);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1, t2;}
{/*@bgen(jjtree) Call */
    try {
/*@egen*/
    // t1=<ID>{jjtThis.jjtSetValue(t1.image);} ["." t2=<ID>{jjtThis.jjtSetSecValue(t2.image);}] <LPAR>
    t1=<ID>{jjtn000.jjtSetValue(t1.image);jjtn000.jjtSetAssignId(t1.image);} ["." t2=<ID>{jjtn000.jjtSetSecValue(t2.image);jjtn000.jjtSetAssignId(t2.image);jjtn000.setAssignIdModule(t1.image);}] <LPAR>

    try{
        [ArgumentList()] <RPAR> <PVIRG>
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN CALL " + e.toString());
        incErrorCounter();
        int[] kinds = {PVIRG, RCHAVETA, LCHAVETA};
        int ret = error_skipto(kinds);
        if(ret == LCHAVETA){
            SpecialStmtlst();
        }
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ArgumentList() : {/*@bgen(jjtree) ArgumentList */
  ASTArgumentList jjtn000 = new ASTArgumentList(JJTARGUMENTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ArgumentList */
    try {
/*@egen*/
    Argument() ( <VIRG> Argument() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Argument() : {/*@bgen(jjtree) Argument */
                   ASTArgument jjtn000 = new ASTArgument(JJTARGUMENT);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
/*@egen*/Token t, t1;}
{/*@bgen(jjtree) Argument */
    try {
/*@egen*/
    ( 
        t=<ID>/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/{jjtn000.jjtSetValue(t.image);jjtn000.addAssignFunctionParameter(t.image,null);} | 
        t=<STRING>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/{jjtn000.jjtSetValue(t.image);jjtn000.addAssignFunctionParameter(null,SimpleNode.Type.STRING);} | 
        [t1=<ADDSUB_OP>{jjtn000.jjtSetSecValue(t1.image);}] t=<INTEGER>/*@bgen(jjtree)*/
                                                                       {
                                                                         jjtree.closeNodeScope(jjtn000, true);
                                                                         jjtc000 = false;
                                                                       }
/*@egen*/{jjtn000.jjtSetValue(t.image); jjtn000.addAssignFunctionParameter(null,SimpleNode.Type.INT);}
    )/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ArrayAccess() : {/*@bgen(jjtree) ArrayAccess */
                      ASTArrayAccess jjtn000 = new ASTArrayAccess(JJTARRAYACCESS);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) ArrayAccess */
    try {
/*@egen*/
    t=<ID>{jjtn000.jjtSetValue(t.image);} "[" Index() "]"/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ScalarAccess() : {/*@bgen(jjtree) ScalarAccess */
                       ASTScalarAccess jjtn000 = new ASTScalarAccess(JJTSCALARACCESS);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/Token t, t1;}
{/*@bgen(jjtree) ScalarAccess */
    try {
/*@egen*/
    t=<ID>{jjtn000.jjtSetValue(t.image);} ["." t1=<SIZE>{jjtn000.jjtSetSecValue(t1.image);}]/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Index() : {/*@bgen(jjtree) Index */
                ASTIndex jjtn000 = new ASTIndex(JJTINDEX);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) Index */
    try {
/*@egen*/
    t=<ID>/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
          }
/*@egen*/{jjtn000.jjtSetValue(t.image);} | t=<INTEGER>/*@bgen(jjtree)*/
                                                       {
                                                         jjtree.closeNodeScope(jjtn000, true);
                                                         jjtc000 = false;
                                                       }
/*@egen*/{jjtn000.jjtSetValue(t.image);jjtn000.jjtSetIntType();}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}


/**
 * Skips tokens until it reads one of the specified tokens
 * @param kinds list of the specified tokens.
 */
JAVACODE
int error_skipto(int[] kinds)       {
    Token t;
    boolean exit = false;
    System.out.print("Tokens skipped: ");
    do {
        t = getNextToken();
        System.out.print(t + " ");
        for(int a : kinds){
            if((a == t.kind) | (t.kind == EOF))
                exit = true;
        }
    } while (!exit);
    System.out.print("\n\n");
    return t.kind;
}

/**
 * Increments the error counter and
 * stops the program if it found more than 10 errors.
 */
JAVACODE
void incErrorCounter(){/*@bgen(jjtree) incErrorCounter */
 ASTincErrorCounter jjtn000 = new ASTincErrorCounter(JJTINCERRORCOUNTER);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 try {
/*@egen*/
    if(yal2jvm.error_counter++ == 10){
        System.out.println("Too many errors found!");
        System.exit(1);
    }/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

/**
 * Begins the Symbol Table generation. 
 * This table stores all information regarding the module.
 * @param root Root node of the AST
 * @return Returns the generated Symbol Table
 */
JAVACODE
SymbolTable generateSymbolTable(Node root) {/*@bgen(jjtree) generateSymbolTable */
 ASTgenerateSymbolTable jjtn000 = new ASTgenerateSymbolTable(JJTGENERATESYMBOLTABLE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 try {
/*@egen*/

    SymbolTable symbolTable = new SymbolTable( (String)((SimpleNode) root).jjtGetValue());
    int numChildren = root.jjtGetNumChildren();

    ArrayList<SymbolTable.Function> allFunctions = new ArrayList<SymbolTable.Function>();
    ArrayList<Node> allStatementsListNodes = new ArrayList<Node>();
    ArrayList<Node> allFunctionsNodes = new ArrayList<Node>();

    for(int i = 0; i < numChildren; i++) {

        SimpleNode node = (SimpleNode) root.jjtGetChild(i);
        int nodeType = node.getId();

        switch (nodeType) {
            case JJTDECLARATION:

               symbolTable.addGlobalDeclaration((String)node.jjtGetValue(),node.getDataType());
               break;
            case JJTFUNCTION:

                String functionName = (String) node.jjtGetValue();
                SimpleNode.Type returnType = node.getDataType();
                SymbolTable.Signature signature = new SymbolTable.Signature(functionName);
                SymbolTable.Function function = new SymbolTable.Function(signature,returnType);
                function.returnVariable = (String)node.jjtGetSecValue();

                Node argumentList;
                Node statementList;

                int functionChildrenNum = node.jjtGetNumChildren();
                statementList = node.jjtGetChild(0);


                if(functionChildrenNum == 2) {

                    argumentList = statementList;
                    statementList = node.jjtGetChild(1);
                    updateSymbolTableFunctionArguments(argumentList, function);
                }

                allFunctions.add(function);
                allStatementsListNodes.add(statementList);
                allFunctionsNodes.add(node);

                symbolTable.addFunction(function);

                break;
            default:
                break;
        }
    }

    for(int i = 0; i < allFunctions.size(); i++) {

        updateSymbolTableFunctionAssigns(allStatementsListNodes.get(i), allFunctions.get(i),symbolTable);
        checkReturnVariable(allFunctions.get(i),symbolTable);
        checkArgsAreNotGlobals(allFunctions.get(i),symbolTable);
        updateSymbolTableFunctionFunctionCalls(allFunctionsNodes.get(i), allFunctions.get(i), symbolTable);

    }

    return symbolTable;/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/

}

/**
 * Verifies if the arguments from a function are global or not
 * @param function Function information
 * @param symbolTable Symbol Table
 */
JAVACODE
void checkArgsAreNotGlobals(SymbolTable.Function function, SymbolTable symbolTable){/*@bgen(jjtree) checkArgsAreNotGlobals */
 ASTcheckArgsAreNotGlobals jjtn000 = new ASTcheckArgsAreNotGlobals(JJTCHECKARGSARENOTGLOBALS);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 try {
/*@egen*/
    HashMap<String,SimpleNode.Type> globals = symbolTable.globalDeclarations;
    ArrayList<String> args = function.signature.arguments;

    for(String arg : args){         
        if(globals.get(arg) != null){
            function.functionIsOk = false;
            if(function.argumentsError != null)
                function.argumentsError += "Semantic Error: Argument " + arg + " is in conflict with global declaration " + arg + "!\n";
            else
                function.argumentsError = "Semantic Error: Argument " + arg + " is in conflict with global declaration " + arg + "!";
            
            function.errors.add(function.argumentsError);
        }
    }/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

/**
 * Verifies the return variable of the function
 * @param function Function information
 * @param symbolTable Symbol Table
 */
JAVACODE
void checkReturnVariable(SymbolTable.Function function, SymbolTable symbolTable){/*@bgen(jjtree) checkReturnVariable */
 ASTcheckReturnVariable jjtn000 = new ASTcheckReturnVariable(JJTCHECKRETURNVARIABLE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 try {
/*@egen*/
    String retVariable = (String)function.returnVariable;

    HashMap<String,SimpleNode.Type> locals = function.localDeclarations;
    HashMap<String,SimpleNode.Type> globals = symbolTable.globalDeclarations;
    ArrayList<String> args = function.signature.arguments;

    if(function.returnVariable == null)
        return;

    if(locals.get(function.returnVariable) != null) {
        
        if(locals.get(function.returnVariable) == function.returnType)
            return;
        function.functionIsOk = false;
        function.errors.add("Semantic Error: The return variable type does not match the function return type!");
        return;
        
    }
    if(globals.get(function.returnVariable) != null) {
        function.functionIsOk = false;
        function.errors.add("Semantic Error: The return variable is a global declaration!");
        return;
    }
    else { 
        int index = function.signature.arguments.indexOf(retVariable);

        if(index != -1) {

            if(function.signature.argumentTypes.get(index) == function.returnType)
                return;
            
            function.functionIsOk = false;
            function.errors.add("Semantic Error: The return variable type does not match the function return type!");
            return;

        }

        function.functionIsOk = false;
        function.errors.add("Semantic Error: The return variable does not exist/is not initialized in the function!");

    }/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

/**
 * Verifies the return variable of the function
 * @param function Function information
 * @param symbolTable Symbol Table
 */
JAVACODE
void updateSymbolTableFunctionArguments(Node argumentList, SymbolTable.Function function) {/*@bgen(jjtree) updateSymbolTableFunctionArguments */
 ASTupdateSymbolTableFunctionArguments jjtn000 = new ASTupdateSymbolTableFunctionArguments(JJTUPDATESYMBOLTABLEFUNCTIONARGUMENTS);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 try {
/*@egen*/

    int numArguments = argumentList.jjtGetNumChildren();

    for(int i = 0; i < numArguments; i++) {

        SimpleNode argument = (SimpleNode) argumentList.jjtGetChild(i);

        if(argument.getId() != JJTELEMENT) {
            function.functionIsOk = false;
            function.errors.add("Argument not of ELEMENT type, check why.");
            continue;
        }

        String argumentName = (String)argument.jjtGetValue();
        SimpleNode.Type argumentDataType = argument.getDataType();
        function.signature.addArgumentType(argumentName,argumentDataType);

    }/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/

}

/**
 * Gets the type of the term
 * @param term Node representing a term
 * @param function Function information
 * @param symbolTable symbol table
 * @return Returns a Pair representing the Type of the term.
 */
JAVACODE
SymbolTable.Pair<String,SimpleNode.Type> getTypeOfTerm(SimpleNode term, SymbolTable.Function function, SymbolTable symbolTable) {/*@bgen(jjtree) getTypeOfTerm */
 ASTgetTypeOfTerm jjtn000 = new ASTgetTypeOfTerm(JJTGETTYPEOFTERM);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 try {
/*@egen*/

    SimpleNode.Type type = term.getDataType();
    String value = (String)term.jjtGetValue();


    if(term.jjtGetNumChildren() > 0) {         

        if(term.jjtGetChild(0).getId() == JJTCALL) {

            SimpleNode callNode = (SimpleNode)term.jjtGetChild(0);
            String functionName = (String)callNode.jjtGetValue();
            String module = null;
            if(callNode.jjtGetSecValue() != null){
                functionName = (String)callNode.jjtGetSecValue();
                module = (String)callNode.jjtGetValue();
            }
    
            //vai buscar a functioncall e tira-lhe o Type para depois comparar com o do lhs
            SymbolTable.FunctionCall fcall = symbolTable.checkGoodFunctionCall(functionName,module,callNode.assignFunctionParameters,function);                
            type = fcall.funcionCallReturnType;
            value = fcall.signature.functionName;

        }

        else if(term.jjtGetChild(0).getId() == JJTINDEX) {
            type = SimpleNode.Type.INT;
        }
    }

    else {

        if(type == null) {
            value = term.getAssignId();
            type = symbolTable.getType(value,function);

        }
    }

    return new SymbolTable.Pair<String,SimpleNode.Type>(value,type);/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/

}

/**
 * Verifies the comparison types
 * @param expression Node representing a expression
 * @param function Function information
 * @param symbolTable Symbol Table
 */
JAVACODE
void checkComparisonTypes(Node expression, SymbolTable.Function function, SymbolTable symbolTable) {/*@bgen(jjtree) checkComparisonTypes */
 ASTcheckComparisonTypes jjtn000 = new ASTcheckComparisonTypes(JJTCHECKCOMPARISONTYPES);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 try {
/*@egen*/

    SimpleNode left = (SimpleNode) expression.jjtGetChild(0);
    SimpleNode.Type lhsType = symbolTable.getType((String)left.jjtGetValue(), function);

    SimpleNode right = (SimpleNode) expression.jjtGetChild(1);
    
    SimpleNode rhsTerm1 = (SimpleNode)right.jjtGetChild(0);
    
    SymbolTable.Pair<String,SimpleNode.Type> rhsTypeTerm1 = getTypeOfTerm(rhsTerm1, function, symbolTable);
    SymbolTable.Pair<String,SimpleNode.Type> rhsTypeTerm2 = null;

    if(right.jjtGetNumChildren() == 2) {

        SimpleNode rhsTerm2 = (SimpleNode)right.jjtGetChild(1);
        rhsTypeTerm2 = getTypeOfTerm(rhsTerm2, function, symbolTable);

        if(rhsTypeTerm1.value != rhsTypeTerm2.value) {

            function.functionIsOk = false;
            function.errors.add("Semantic Error: invalid expression in rhs, " + rhsTypeTerm1.key + " is of different type of " + rhsTypeTerm2.key);

        }

        else {

            if(lhsType != rhsTypeTerm1.value) {
                function.functionIsOk = false;
                function.errors.add("Semantic Error: invalid comparison, " + left.jjtGetValue() + " is of different type of comparison expression" );
            }
        
            else {
                if(lhsType != SimpleNode.Type.INT) {
                    function.errors.add("Semantic Error: invalid comparison, " + left.jjtGetValue() + " is not Integer");
                }
            }

        }

    }

    else {

        if(lhsType != rhsTypeTerm1.value) {
            function.functionIsOk = false;
            function.errors.add("Semantic Error: invalid comparison, " + left.jjtGetValue() + " is of different type of comparison expression" );
        }
    
        else {
            if(lhsType != SimpleNode.Type.INT) {
                function.functionIsOk = false;
                function.errors.add("Semantic Error: invalid comparison, " + left.jjtGetValue() + " is not Integer");
            }
        }


    }/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/

}


/**
 * Updates the Symbol Table's Assignments
 * @param statementList Node representing a statementList
 * @param function Function information
 * @param symbolTable Symbol Table
 */
JAVACODE
void updateSymbolTableFunctionAssigns(Node statementList, SymbolTable.Function function, SymbolTable symbolTable) {/*@bgen(jjtree) updateSymbolTableFunctionAssigns */
 ASTupdateSymbolTableFunctionAssigns jjtn000 = new ASTupdateSymbolTableFunctionAssigns(JJTUPDATESYMBOLTABLEFUNCTIONASSIGNS);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 try {
/*@egen*/

    for(int i = 0; i < statementList.jjtGetNumChildren(); i++){

        SimpleNode statement = (SimpleNode)statementList.jjtGetChild(i);

        SimpleNode statementChild = (SimpleNode)statement.jjtGetChild(0);

        switch(statementChild.getId()){
            
            case JJTASSIGN:
            
                SimpleNode lhs = (SimpleNode)statementChild.jjtGetChild(0);

                if(lhs.jjtGetSecValue() != null) {
                    function.functionIsOk = false;
                    function.errors.add("Can't assign size of array " + lhs.jjtGetValue());
                    break;

                }

                if(lhs.jjtGetNumChildren() > 0)
                    break;
                    

                SimpleNode.Type lhsType = symbolTable.getType((String)lhs.jjtGetValue(), function);

                SimpleNode rhs = (SimpleNode)statementChild.jjtGetChild(1);                
                SimpleNode rhsTerm1 = (SimpleNode)rhs.jjtGetChild(0);
                
                SymbolTable.Pair<String,SimpleNode.Type> rhsTypeTerm1 = getTypeOfTerm(rhsTerm1, function, symbolTable);
                SymbolTable.Pair<String,SimpleNode.Type> rhsTypeTerm2 = null;
            
                if(rhs.jjtGetNumChildren() == 2) {
            
                    SimpleNode rhsTerm2 = (SimpleNode)rhs.jjtGetChild(1);
                    rhsTypeTerm2 = getTypeOfTerm(rhsTerm2, function, symbolTable);
            
                    if(rhsTypeTerm1.value != rhsTypeTerm2.value) {
                        function.functionIsOk = false;
                        function.errors.add("Semantic Error: invalid expression in rhs, " + rhsTypeTerm1.key + " is of different type of " + rhsTypeTerm2.key);
                    }
                    
                }
                        
                if(lhs.getDataType() == null)
                    lhs.jjtSetType(rhsTypeTerm1.value);
                
                else{
                    if(lhs.getDataType() != rhsTypeTerm1.value){
                        function.errors.add("Semantic Error in assignment: conflict types between " + lhs.value + " and " + rhsTypeTerm1.key);
                    }
                }

                function.addLocalDeclaration((String)lhs.value, lhs.getDataType(), symbolTable.globalDeclarations);
                break;

            case JJTIF:

                checkComparisonTypes((SimpleNode) statementChild.jjtGetChild(0),function, symbolTable);
                for(int x = 1; x < statementChild.jjtGetNumChildren(); x++){
                    SimpleNode statementListIfWhile = (SimpleNode) statementChild.jjtGetChild(x);
                    updateSymbolTableFunctionAssigns(statementListIfWhile, function, symbolTable);
                }
                break;

            case JJTWHILE:
                checkComparisonTypes((SimpleNode) statementChild.jjtGetChild(0),function, symbolTable);
                SimpleNode statementListIfWhile = (SimpleNode) statementChild.jjtGetChild(1);
                updateSymbolTableFunctionAssigns(statementListIfWhile, function, symbolTable);
                break;

            default:
                break;
        }
    }
    System.out.println();/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

/**
 * Updates the Symbol Table's Function Calls
 * @param node Node from the AST
 * @param function Function information
 * @param symbolTable Symbol Table
 */
JAVACODE
void updateSymbolTableFunctionFunctionCalls(Node node, SymbolTable.Function function, SymbolTable symbolTable) {/*@bgen(jjtree) updateSymbolTableFunctionFunctionCalls */
 ASTupdateSymbolTableFunctionFunctionCalls jjtn000 = new ASTupdateSymbolTableFunctionFunctionCalls(JJTUPDATESYMBOLTABLEFUNCTIONFUNCTIONCALLS);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 try {
/*@egen*/

    SimpleNode currentNode = (SimpleNode) node;

    if(currentNode.getId() == JJTCALL) {

        String functionName = (String)currentNode.jjtGetValue();
        String moduleName = null;

        if(currentNode.jjtGetSecValue() != null) {
            moduleName = functionName;
            functionName = (String) currentNode.jjtGetSecValue();
        }

        ArrayList<SymbolTable.Pair<String,SimpleNode.Type>> functionCallParameters = currentNode.assignFunctionParameters;

        SymbolTable.FunctionCall functionCall = symbolTable.checkGoodFunctionCall(functionName, moduleName, functionCallParameters, function);

        function.addFunctionCall(functionCall);

    }

    else {

        for(int i = 0; i < currentNode.jjtGetNumChildren(); i++) {

            updateSymbolTableFunctionFunctionCalls(currentNode.jjtGetChild(i),function, symbolTable);

        }
    }/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/

}