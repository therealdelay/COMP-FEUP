options{
    NODE_PACKAGE = "yal";
    MULTI=true;
}

PARSER_BEGIN(yal2jvm)

package yal;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.IOException;
import java.util.*;


public class yal2jvm {
    public static int error_counter = 0;
    private static SimpleNode astRoot = null;
    public static void main(String args[]) throws ParseException, IOException {
        InputStream f = null;
        boolean showAst = false;
        boolean showSymbolTable = false;
        boolean generateJavaBytecodes = false;
        Scanner scanner = new Scanner(System.in);

        System.out.println("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
        System.out.println("#########################################");
        System.out.println("# Yal Compiler Project 2018 - Group G33 #");
        System.out.println("#########################################");

        if(args.length == 0){
            System.out.println("Proper Usage is: ./script filename \n Example: ./script yalExamples/MyFirstYalExamples/aval1.j");
            System.exit(0);
        }
        
        String fileName = args[0];

        System.out.println("Your file is " + fileName);

        try {
            f = new FileInputStream(/*"../yalExamples/" + */ "../" + fileName);
        }catch(FileNotFoundException e) {
            System.out.println(e.getMessage());
            return;
        }

        System.out.print("\nWould you like to see the AST?(1-Yes;0-No)  ");
        int astInput = scanner.nextInt();
        if(astInput == 1)
            showAst = true;
        else if(astInput != 0){
            System.out.println("Error in option!");
            return;
        }

        System.out.print("\nWould you like to see the Symbol Table?(1-Yes;0-No)  ");
        int symbolTableInput = scanner.nextInt();
        if(symbolTableInput == 1)
            showSymbolTable = true;
        else if(symbolTableInput != 0){
            System.out.println("Error in option!");
            return;
        }

        System.out.print("\nWould you like to generate Java Bytecodes in a jasmin file?(1-Yes;0-No)  ");
        int bytecodesInput = scanner.nextInt();
        if(bytecodesInput == 1)
            generateJavaBytecodes = true;
        else if(bytecodesInput != 0){
            System.out.println("Error in option!");
            return;
        }

        yal2jvm parser = new yal2jvm(f);
        astRoot = parser.Module();
        System.out.println("\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n");
        System.out.println("File " + fileName + " parsed with " + error_counter + " syntactic errors\n");
        
        if(showAst){
            System.out.println("AST:");
            astRoot.dump("");
        }

        SymbolTable symbolTable = generateSymbolTable(astRoot);
        if(showSymbolTable)
            System.out.println("Symbol Table:\n" + symbolTable);


        if(generateJavaBytecodes)
            Bytecodes.generateJavaBytecodes(astRoot, symbolTable);
        
        System.out.println();
    }
}

PARSER_END(yal2jvm)

SKIP : {
    " "
    | "\t"
    | "\n"
    | "\r"
    | <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
    | <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

/* reserved words */
TOKEN : {
    <RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
    | <ADDSUB_OP: "+" | "-">
    | <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
    | <BITWISE_OP: "&" | "|" | "^">
    | <NOT_OP: "!">
    | <WHILE: "while">
    | <IF: "if">
    | <ELSE: "else">
    | <ASSIGN: "=">
    | <ASPA: "\"">
    | <LPAR: "(">
    | <RPAR: ")">
    | <VIRG: ",">
    | <PVIRG: ";">
    | <LCHAVETA: "{">
    | <RCHAVETA: "}">
    | <FUNCTION: "function">
    | <MODULE: "module">
    | <SIZE: "size">
}

TOKEN : {
    <INTEGER: (<DIGIT>)+>
    | <ID: <LETTER> (<LETTER> | <DIGIT>)*>
    | <#LETTER: ["$","A"-"Z","_","a"-"z"]>
    | <#DIGIT: ["0"-"9"]>
    | <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}

SimpleNode Module() : {Token t;}{
    try{
        <MODULE> t=<ID>{jjtThis.jjtSetValue(t.image);} <LCHAVETA> (LOOKAHEAD(3) Declaration())* (Function())* <RCHAVETA>
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN MODULE " + e.toString());
        incErrorCounter();
        int[] kinds = {RCHAVETA, EOF};
        error_skipto(kinds);
    }
    {return jjtThis;}
}

void Declaration() : {Token t, t2;}{

    t=<ID>{jjtThis.jjtSetValue(t.image);} ["[" "]" {jjtThis.jjtSetArrayType();}]
    [
    <ASSIGN>
    try{
        (("[" ArraySize() "]") {jjtThis.jjtSetArrayType();} | [<ADDSUB_OP>] t2=<INTEGER>{jjtThis.jjtSetIntType();})
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN DECLARATION " + e.toString());
        incErrorCounter();
        int[] kinds = {PVIRG};
        error_skipto(kinds);
    }
    ]
    try{
        <PVIRG>
    }
    catch(ParseException e){
        System.out.println("EXCEPTION IN DECLARATION " + e.toString());
        incErrorCounter();
        int[] kinds = {PVIRG};
        error_skipto(kinds);
    }
}


void Function() : {Token t1, t2;}{

    try{
        <FUNCTION>{jjtThis.jjtSetType(SimpleNode.Type.VOID);} [LOOKAHEAD(2) t2=<ID>{jjtThis.jjtSetSecValue(t2.image);jjtThis.jjtSetIntType();} ["[" "]"{jjtThis.jjtSetArrayType();}] <ASSIGN>] t1=<ID>{jjtThis.jjtSetValue(t1.image);}
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN FUNCTION " + e.toString());
        incErrorCounter();
        int[] kinds = {PVIRG, LCHAVETA, LPAR, ID};
        error_skipto(kinds);
    }

    try{
        <LPAR> [Varlist()] <RPAR>
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN FUNCTION " + e.toString());
        incErrorCounter();
        int[] kinds = {RPAR};
        error_skipto(kinds);
    }
    <LCHAVETA> Stmtlst() <RCHAVETA>
}

void Varlist() : {}{
    (Element()) ( <VIRG> Element() )*
}

void ArrayElement() : {Token t;}
{
    t=<ID>{jjtThis.jjtSetValue(t.image);} "[" "]"
}

void Element() : {Token t;}
{
    t=<ID>{jjtThis.jjtSetValue(t.image); jjtThis.jjtSetIntType();} ["[" "]"{jjtThis.jjtSetArrayType();}]
}

void ScalarElement() : {Token t;}
{
    t=<ID>{jjtThis.jjtSetValue(t.image);}
}

void Stmtlst() : {}
{
    ( Stmt() )*
}

void SpecialStmtlst() #void : {}
{
    Stmtlst() <RCHAVETA>
}

void Stmt() : {}
{
    try{
        If() | While() | LOOKAHEAD(3) Assign() | Callstmt()
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN STMT " + e.toString());
        incErrorCounter();
        int[] kinds = {RPAR, PVIRG, LCHAVETA};
        error_skipto(kinds);
    }
}

void Assign() : {}
{
    Lhs() <ASSIGN>
    try{
        Rhs() <PVIRG>
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN ASSIGN " + e.toString());
        incErrorCounter();
        int[] kinds = {PVIRG};
        error_skipto(kinds);
    }
}

void Lhs() : {Token t;}
{
    t=<ID>{jjtThis.jjtSetValue(t.image);} ( ("[" Index() "]" {jjtThis.jjtSetArrayType();})|["." <SIZE>] )
}

void Rhs() : {Token t;}
{
    (Term() [(t=<ARITH_OP>| t=<BITWISE_OP> | t=<ADDSUB_OP>){jjtThis.jjtSetValue(t.image);}  Term()]) | "[" ArraySize(){((SimpleNode)jjtThis).jjtSetArrayType();} "]"
}

void ArraySize() : {Token t;}
{
    ScalarAccess() | t=<INTEGER>{jjtThis.jjtSetValue(t.image);}
}

void Term() : {Token t1,t2,t3,t4;}
{
    [t1=<ADDSUB_OP>{jjtThis.jjtSetSecValue(t1.image);}] (t2=<INTEGER>{jjtThis.jjtSetValue(t2.image);jjtThis.jjtSetIntType();} | LOOKAHEAD(3) Call() | (t3=<ID>{jjtThis.jjtSetValue(t3.image);jjtThis.jjtSetAssignId(t3.image);} (("[" Index() "]")|(["." t4=<SIZE>{jjtThis.jjtSetSecValue(t4.image);jjtThis.jjtSetIntType();}]))))
}

void Exprtest() : {Token t;}
{
    try{
        <LPAR> Lhs() t=<RELA_OP>{jjtThis.jjtSetRelaOp(t.image);} Rhs() <RPAR>
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN EXPRTEST " + e.toString());
        incErrorCounter();
        int[] kinds = {RPAR};
        error_skipto(kinds);
    }
}

void While() : {}
{
    <WHILE> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA>
}

void If() : {}
{
    <IF> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA>

    try{
        [<ELSE> <LCHAVETA> Stmtlst() <RCHAVETA>]
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN ELSE " + e.toString());
        incErrorCounter();
        int[] kinds = {PVIRG};
        error_skipto(kinds);
    }
}

void Call() : {Token t1, t2;}
{
    t1=<ID>{jjtThis.jjtSetValue(t1.image);jjtThis.jjtSetAssignId(t1.image);} ["." t2=<ID>{jjtThis.jjtSetSecValue(t2.image);jjtThis.jjtSetAssignId(t2.image);jjtThis.setAssignIdModule(t1.image);}] <LPAR>

    try{
        [ArgumentList()] <RPAR>
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN CALL " + e.toString());
        incErrorCounter();
        int[] kinds = {RCHAVETA, LCHAVETA, RPAR};
        int ret = error_skipto(kinds);
        if(ret == LCHAVETA){
            SpecialStmtlst();
        }
    }
}

void Callstmt() #Call : {Token t1, t2;}
{
    // t1=<ID>{jjtThis.jjtSetValue(t1.image);} ["." t2=<ID>{jjtThis.jjtSetSecValue(t2.image);}] <LPAR>
    t1=<ID>{jjtThis.jjtSetValue(t1.image);jjtThis.jjtSetAssignId(t1.image);} ["." t2=<ID>{jjtThis.jjtSetSecValue(t2.image);jjtThis.jjtSetAssignId(t2.image);jjtThis.setAssignIdModule(t1.image);}] <LPAR>

    try{
        [ArgumentList()] <RPAR> <PVIRG>
    }
    catch (ParseException e) {
        System.out.println("EXCEPTION IN CALL " + e.toString());
        incErrorCounter();
        int[] kinds = {PVIRG, RCHAVETA, LCHAVETA};
        int ret = error_skipto(kinds);
        if(ret == LCHAVETA){
            SpecialStmtlst();
        }
    }
}

void ArgumentList() : {}
{
    Argument() ( <VIRG> Argument() )*
}

void Argument() : {Token t, t1;}
{
    ( 
        t=<ID>{jjtThis.jjtSetValue(t.image);jjtThis.addAssignFunctionParameter(t.image,null);} | 
        t=<STRING>{jjtThis.jjtSetValue(t.image);jjtThis.addAssignFunctionParameter(null,SimpleNode.Type.STRING);} | 
        [t1=<ADDSUB_OP>{jjtThis.jjtSetSecValue(t1.image);}] t=<INTEGER>{jjtThis.jjtSetValue(t.image); jjtThis.addAssignFunctionParameter(null,SimpleNode.Type.INT);}
    )
}

void ArrayAccess() : {Token t;}
{
    t=<ID>{jjtThis.jjtSetValue(t.image);} "[" Index() "]"
}

void ScalarAccess() : {Token t, t1;}
{
    t=<ID>{jjtThis.jjtSetValue(t.image);} ["." t1=<SIZE>{jjtThis.jjtSetSecValue(t1.image);}]
}

void Index() : {Token t;}
{
    t=<ID>{jjtThis.jjtSetValue(t.image);} | t=<INTEGER>{jjtThis.jjtSetValue(t.image);}
}


JAVACODE
int error_skipto(int[] kinds) #void {
    Token t;
    boolean exit = false;
    System.out.print("Tokens skipped: ");
    do {
        t = getNextToken();
        System.out.print(t + " ");
        for(int a : kinds){
            if((a == t.kind) | (t.kind == EOF))
                exit = true;
        }
    } while (!exit);
    System.out.print("\n\n");
    return t.kind;
}

JAVACODE
void incErrorCounter(){
    if(yal2jvm.error_counter++ == 10){
        System.out.println("Too many errors found!");
        System.exit(1);
    }
}

JAVACODE
SymbolTable generateSymbolTable(Node root) {

    SymbolTable symbolTable = new SymbolTable( (String)((SimpleNode) root).jjtGetValue());
    int numChildren = root.jjtGetNumChildren();

    ArrayList<SymbolTable.Function> allFunctions = new ArrayList<SymbolTable.Function>();
    ArrayList<Node> allStatementsListNodes = new ArrayList<Node>();
    ArrayList<Node> allFunctionsNodes = new ArrayList<Node>();

    for(int i = 0; i < numChildren; i++) {

        SimpleNode node = (SimpleNode) root.jjtGetChild(i);
        int nodeType = node.getId();

        switch (nodeType) {
            case JJTDECLARATION:

            symbolTable.addGlobalDeclaration((String)node.jjtGetValue(),node.getDataType());
            break;

            case JJTFUNCTION:

            String functionName = (String) node.jjtGetValue();
            SimpleNode.Type returnType = node.getDataType();
            SymbolTable.Signature signature = new SymbolTable.Signature(functionName);
            SymbolTable.Function function = new SymbolTable.Function(signature,returnType);
            function.returnVariable = (String)node.jjtGetSecValue();

            /**
             * verificar se tem argumentos ou apenas statements
             */

            Node argumentList;
            Node statementList;

            int functionChildrenNum = node.jjtGetNumChildren();
            statementList = node.jjtGetChild(0);

            // System.out.println("Function Name: " + signature.functionName);

            if(functionChildrenNum == 2) {

                argumentList = statementList;
                statementList = node.jjtGetChild(1);
                updateSymbolTableFunctionArguments(argumentList, function);


            }

            allFunctions.add(function);
            allStatementsListNodes.add(statementList);
            allFunctionsNodes.add(node);

            //add function
            symbolTable.addFunction(function);

            break;

            default:
                break;
        }
    }

    for(int i = 0; i < allFunctions.size(); i++) {

        updateSymbolTableFunctionAssigns(allStatementsListNodes.get(i), allFunctions.get(i),symbolTable);
        checkReturnVariable(allFunctions.get(i),symbolTable);
        checkArgsAreNotGlobals(allFunctions.get(i),symbolTable);
        updateSymbolTableFunctionFunctionCalls(allFunctionsNodes.get(i), allFunctions.get(i), symbolTable);

    }

    return symbolTable;

}

JAVACODE
void checkArgsAreNotGlobals(SymbolTable.Function function, SymbolTable symbolTable){
    HashMap<String,SimpleNode.Type> globals = symbolTable.globalDeclarations;
    ArrayList<String> args = function.signature.arguments;

    for(String arg : args){         
        if(globals.get(arg) != null){
            function.functionIsOk = false;
            if(function.argumentsError != null)
                function.argumentsError += "Semantic Error: Argument " + arg + " is in conflict with global declaration " + arg + "!\n";
            else
                function.argumentsError = "Semantic Error: Argument " + arg + " is in conflict with global declaration " + arg + "!";
        }
    }
}

JAVACODE
void checkReturnVariable(SymbolTable.Function function, SymbolTable symbolTable){
    String retVariable = (String)function.returnVariable;

    System.out.println("Ret Value: " + retVariable);

    for(String localVar : function.localDeclarations.keySet()) {
        System.out.println("localVar: " + localVar);
        System.out.println("type: " + function.localDeclarations.get(localVar));
    }

    HashMap<String,SimpleNode.Type> locals = function.localDeclarations;
    HashMap<String,SimpleNode.Type> globals = symbolTable.globalDeclarations;
    ArrayList<String> args = function.signature.arguments;

    if(function.returnVariable == null)
        return;

    if(locals.get(function.returnVariable) != null){
        
        if(locals.get(function.returnVariable) == function.returnType)
            return;
        function.functionIsOk = false;
        function.returnVariableError = "Semantic Error: The return variable type does not match the function return type!";
        return;
        
    }
    if(globals.get(function.returnVariable) != null){
        function.functionIsOk = false;
        function.returnVariableError = "Semantic Error: The return variable is a global declaration!";
        return;
    }
    else{
        int index = function.signature.arguments.indexOf(retVariable);

        if(index != -1) {

            if(function.signature.argumentTypes.get(index) == function.returnType)
                return;
            
            function.functionIsOk = false;
            function.returnVariableError = "Semantic Error: The return variable type does not match the function return type!";
            return;

        }

        function.functionIsOk = false;
        function.returnVariableError = "Semantic Error: The return variable does not exist/is not initialized in the function!";

    }
}

JAVACODE
void updateSymbolTableFunctionArguments(Node argumentList, SymbolTable.Function function) {

    int numArguments = argumentList.jjtGetNumChildren();

    for(int i = 0; i < numArguments; i++) {

        SimpleNode argument = (SimpleNode) argumentList.jjtGetChild(i);

    //apenas uma verificação redundante se é do tipo elemento
        if(argument.getId() != JJTELEMENT) {

            System.out.println("Argument not of ELEMENT type, check why.");
            continue;
        }

        String argumentName = (String)argument.jjtGetValue();
        SimpleNode.Type argumentDataType = argument.getDataType();
        function.signature.addArgumentType(argumentName,argumentDataType);

    }

}

JAVACODE
void updateSymbolTableFunctionAssigns(Node statementList, SymbolTable.Function function, SymbolTable symbolTable) {

    for(int i = 0; i < statementList.jjtGetNumChildren(); i++){

        SimpleNode statement = (SimpleNode)statementList.jjtGetChild(i);

        SimpleNode statementChild = (SimpleNode)statement.jjtGetChild(0);

        switch(statementChild.getId()){
            case JJTASSIGN:
            SimpleNode lhs = (SimpleNode)statementChild.jjtGetChild(0);
            SimpleNode rhs = (SimpleNode)statementChild.jjtGetChild(1);
            SimpleNode rhsChild = (SimpleNode)rhs.jjtGetChild(0);
            String rhsValue = (String)rhs.jjtGetValue();
            SimpleNode.Type rhsType = rhs.getDataType();

            if(rhsChild.jjtGetNumChildren() > 0){ //so entra neste if se for uma function call
                //quando não tem module -> first value = nome da funcao
                //quanto tem module -> first value = nome do module
                SimpleNode callNode = (SimpleNode)rhsChild.jjtGetChild(0);
                String functionName = (String)callNode.jjtGetValue();
                String module = null;
                if(callNode.jjtGetSecValue() != null){
                    functionName = (String)callNode.jjtGetSecValue();
                    module = (String)callNode.jjtGetValue();
                }

                //vai buscar a functioncall e tira-lhe o Type para depois comparar com o do lhs
                SymbolTable.FunctionCall fcall = symbolTable.checkGoodFunctionCall(functionName,module,callNode.assignFunctionParameters,function);
                rhsType = fcall.funcionCallReturnType;

            }
            else { //entra neste else se for ID ou um inteiro
                if(statementChild.getAssignId() != null)
                    rhsType = symbolTable.getType(statementChild.getAssignId(),function);

                if(rhsValue == null)
                    rhsValue = (String)rhsChild.jjtGetValue();

                if(rhsType == null)
                    rhsType = rhsChild.getDataType();

            }

            // verificar se os types dos 2 membros do assign coincidem
            if(lhs.getDataType() == null)
                lhs.jjtSetType(rhsType);
            else{
                if(lhs.getDataType() != rhsType){
                    System.out.println("Semantic Error: conflict types between " + lhs.value + " and " + rhsValue);
                }
            }
            //verificar se está em alguma das tabelas (local ou global)
            function.addLocalDeclaration((String)lhs.value, lhs.getDataType(), symbolTable.globalDeclarations);
            break;

            case JJTIF:
                for(int x = 1; x < statementChild.jjtGetNumChildren(); x++){
                    SimpleNode statementListIfWhile = (SimpleNode) statementChild.jjtGetChild(x);
                    updateSymbolTableFunctionAssigns(statementListIfWhile, function, symbolTable);
                }
                break;
            case JJTWHILE:
                SimpleNode statementListIfWhile = (SimpleNode) statementChild.jjtGetChild(1);
                updateSymbolTableFunctionAssigns(statementListIfWhile, function, symbolTable);
            break;

            default:
            break;
        }
    }
    System.out.println();
}


JAVACODE
void updateSymbolTableFunctionFunctionCalls(Node node, SymbolTable.Function function, SymbolTable symbolTable) {

    SimpleNode currentNode = (SimpleNode) node;

    if(currentNode.getId() == JJTCALL) {

        String functionName = (String)currentNode.jjtGetValue();
        String moduleName = null;

        if(currentNode.jjtGetSecValue() != null) {
            moduleName = functionName;
            functionName = (String) currentNode.jjtGetSecValue();
        }

        ArrayList<SymbolTable.Pair<String,SimpleNode.Type>> functionCallParameters = currentNode.assignFunctionParameters;

        SymbolTable.FunctionCall functionCall = symbolTable.checkGoodFunctionCall(functionName, moduleName, functionCallParameters, function);

        function.addFunctionCall(functionCall);

    }

    else {

        for(int i = 0; i < currentNode.jjtGetNumChildren(); i++) {

            updateSymbolTableFunctionFunctionCalls(currentNode.jjtGetChild(i),function, symbolTable);

        }



    }

}