options{

	MULTI=true;
}

PARSER_BEGIN(yal2jvm)

 

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.IOException;
import java.util.*;

public class yal2jvm {
	public static int error_counter = 0;
	private static SimpleNode astRoot = null;
	public static void main(String args[]) throws ParseException, IOException {
		InputStream f = null;

		try { 
			f = new FileInputStream("../yalExamples/" + args[0]);
		}catch(FileNotFoundException e) {
			System.out.println(e.getMessage());
		}

		System.out.println("File: " + args[0]);

		yal2jvm parser = new yal2jvm(f);

		astRoot = parser.Module();

		System.out.print("Error count: " + error_counter + "\n\n");
		
		//System.out.println("AST:");
		//astRoot.dump("");

		// buildSymbolTable(astRoot);

		SymbolTable symbolTable = generateSymbolTable(astRoot);
		generateJavaBytecodes(astRoot);
		// System.out.println(symbolTable);


		System.out.print("\n\n\n");
	}
}

PARSER_END(yal2jvm)

SKIP : {
	" "
	| "\t"
	| "\n"
	| "\r"
	| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
	| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

/* reserved words */
TOKEN : {
	<RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
	| <ADDSUB_OP: "+" | "-">
	| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
	| <BITWISE_OP: "&" | "|" | "^">
	| <NOT_OP: "!">
	| <WHILE: "while">
	| <IF: "if">
	| <ELSE: "else">
	| <ASSIGN: "=">
	| <ASPA: "\"">
	| <LPAR: "(">
	| <RPAR: ")">
	| <VIRG: ",">
	| <PVIRG: ";">
	| <LCHAVETA: "{">
	| <RCHAVETA: "}">
	| <FUNCTION: "function">
	| <MODULE: "module">
	| <SIZE: "size">
}

TOKEN : {
	<INTEGER: (<DIGIT>)+>
	| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
	| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
	| <#DIGIT: ["0"-"9"]>
	| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}

SimpleNode Module() : {Token t;}{
	try{
		<MODULE> t=<ID>{jjtThis.jjtSetValue(t.image);} <LCHAVETA> (LOOKAHEAD(3) Declaration())* (Function())* <RCHAVETA>
	}
	catch (ParseException e) {
			System.out.println("EXCEPTION IN MODULE " + e.toString());
			incErrorCounter();
			int[] kinds = {RCHAVETA, EOF};
			error_skipto(kinds);
	}
	{return jjtThis;}
}

void Declaration() : {Token t, t2;}{

	t=<ID>{jjtThis.jjtSetValue(t.image);} ["[" "]" {jjtThis.jjtSetArrayType();}]
	[
		<ASSIGN>
		try{
			(("[" ArraySize() "]") {jjtThis.jjtSetArrayType();} | [<ADDSUB_OP>] t2=<INTEGER>{jjtThis.jjtSetIntType();})
		}
		catch (ParseException e) {
			System.out.println("EXCEPTION IN DECLARATION " + e.toString());
			incErrorCounter();
			int[] kinds = {PVIRG};
			error_skipto(kinds);
		}
	]
	try{
		<PVIRG>
	}
	catch(ParseException e){
		System.out.println("EXCEPTION IN DECLARATION " + e.toString());
		incErrorCounter();
		int[] kinds = {PVIRG};
		error_skipto(kinds);
	}
}


void Function() : {Token t1, t2;}{

	try{
		<FUNCTION> [LOOKAHEAD(2) t2=<ID>{jjtThis.jjtSetSecValue(t2.image);} ["[" "]"] <ASSIGN>] t1=<ID>{jjtThis.jjtSetValue(t1.image);}
	}
	catch (ParseException e) {
			System.out.println("EXCEPTION IN FUNCTION " + e.toString());
			incErrorCounter();
			int[] kinds = {PVIRG, LCHAVETA, LPAR, ID};
			error_skipto(kinds);
	}

	try{
		<LPAR> [Varlist()] <RPAR>
	}
	catch (ParseException e) {
			System.out.println("EXCEPTION IN FUNCTION " + e.toString());
			incErrorCounter();
			int[] kinds = {RPAR};
			error_skipto(kinds);
	}
	<LCHAVETA> Stmtlst() <RCHAVETA>
}

void Varlist() : {}{
	(Element()) ( <VIRG> Element() )*
}

void ArrayElement() : {Token t;}
{
	t=<ID>{jjtThis.jjtSetValue(t.image);} "[" "]"
}

void Element() : {Token t;}
{
	t=<ID>{jjtThis.jjtSetValue(t.image); jjtThis.jjtSetIntType();} ["[" "]"{jjtThis.jjtSetArrayType();}]
}

void ScalarElement() : {Token t;}
{
	t=<ID>{jjtThis.jjtSetValue(t.image);}
}

void Stmtlst() : {}
{
	( Stmt() )*
} 

void SpecialStmtlst() #void : {}
{
	Stmtlst() <RCHAVETA>
} 

void Stmt() : {}
{
	try{
		If() | While() | LOOKAHEAD(3) Assign() | Callstmt()
	}
	catch (ParseException e) {
		System.out.println("EXCEPTION IN STMT " + e.toString());
		incErrorCounter();
		int[] kinds = {RPAR, PVIRG, LCHAVETA};
		error_skipto(kinds);
	}
}

void Assign() : {}
{
	Lhs() <ASSIGN>
	try{
		Rhs() <PVIRG>
	}
	catch (ParseException e) {
		System.out.println("EXCEPTION IN ASSIGN " + e.toString());
		incErrorCounter();
		int[] kinds = {PVIRG};
		error_skipto(kinds);
	}
}

void Lhs() : {Token t;}
{
	t=<ID>{jjtThis.jjtSetValue(t.image);} (("[" Index() "]")|( LhsArraySize() ))
}

void LhsArraySize() : {}
{
	["." <SIZE>]
}
void Rhs() : {}
{
	(Term() [(<ARITH_OP> | <BITWISE_OP> | <ADDSUB_OP>) Term()]) | "[" ArraySize(){((SimpleNode)jjtThis.jjtGetParent()).jjtSetArrayType();} "]"
}

void ArraySize() : {}
{
	ScalarAccess() | <INTEGER>
}

void Term() : {Token t1,t2,t3, t4;}
{
[t1=<ADDSUB_OP>{jjtThis.jjtSetValue(t1.image);}] (t2=<INTEGER>{jjtThis.jjtSetValue(t2.image);jjtThis.jjtSetIntType();} | LOOKAHEAD(3) Call() | (t3=<ID>{jjtThis.jjtSetValue(t3.image);jjtThis.jjtSetIntType();jjtThis.jjtSetAssignId(t3.image);} (("[" Index() "]")|(["." t4=<SIZE>{jjtThis.jjtSetValue(t4.image);}]))))
}

void Exprtest() : {}
{
	try{
		<LPAR> Lhs() <RELA_OP> Rhs() <RPAR>
	}
	catch (ParseException e) {
		System.out.println("EXCEPTION IN EXPRTEST " + e.toString());
		incErrorCounter();
		int[] kinds = {RPAR};
		error_skipto(kinds);
	}	
}

void While() : {}
{
	<WHILE> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA>
}

void If() : {}
{
	<IF> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA> 

	try{
		[<ELSE> <LCHAVETA> Stmtlst() <RCHAVETA>]
	}
	catch (ParseException e) {
		System.out.println("EXCEPTION IN ELSE " + e.toString());
		incErrorCounter();
		int[] kinds = {PVIRG};
		error_skipto(kinds);
	}
}

void Call() : {Token t1, t2;}
{
	t1=<ID>{jjtThis.jjtSetValue(t1.image);jjtThis.jjtSetAssignId(t1.image);} ["." t2=<ID>{jjtThis.jjtSetSecValue(t2.image);jjtThis.jjtSetAssignId(t2.image);jjtThis.setAssignIdModule(t1.image);}] <LPAR>	

	try{
		[ArgumentList()] <RPAR>
	}
	catch (ParseException e) {
		System.out.println("EXCEPTION IN CALL " + e.toString());
		incErrorCounter();
		int[] kinds = {RCHAVETA, LCHAVETA, RPAR};
		int ret = error_skipto(kinds);
		if(ret == LCHAVETA){
			SpecialStmtlst();
		}
	}
}

void Callstmt() #Call : {Token t1, t2;}
{
	t1=<ID>{jjtThis.jjtSetValue(t1.image);} ["." t2=<ID>{jjtThis.jjtSetSecValue(t2.image);}] <LPAR>	

	try{
		[ArgumentList()] <RPAR> <PVIRG>
	}
	catch (ParseException e) {
		System.out.println("EXCEPTION IN CALL " + e.toString());
		incErrorCounter();
		int[] kinds = {PVIRG, RCHAVETA, LCHAVETA};
		int ret = error_skipto(kinds);
		if(ret == LCHAVETA){
			SpecialStmtlst();
		}
	}
}

void ArgumentList() : {}
{
	Argument() ( <VIRG> Argument() )*
}

void Argument() : {Token t;}
{
	( t=<ID>{jjtThis.jjtSetValue(t.image);jjtThis.addAssignFunctionParameter(t.image,null);} | t=<STRING>{jjtThis.jjtSetValue(t.image);jjtThis.addAssignFunctionParameter(null,SimpleNode.Type.STRING);} | t=<INTEGER>{jjtThis.jjtSetValue(t.image); jjtThis.addAssignFunctionParameter(null,SimpleNode.Type.INT);})
}

void ArrayAccess() : {Token t;}
{
	t=<ID>{jjtThis.jjtSetValue(t.image);} "[" Index() "]"
}

void ScalarAccess() : {Token t, t1;}
{
	t=<ID>{jjtThis.jjtSetValue(t.image);} ["." t1=<SIZE>{jjtThis.jjtSetSecValue(t1.image);}]
}

void Index() : {Token t;}
{
	t=<ID>{jjtThis.jjtSetValue(t.image);} | t=<INTEGER>{jjtThis.jjtSetValue(t.image);}
}

JAVACODE
int error_skipto(int[] kinds) #void {
  Token t;
  boolean exit = false;
  System.out.print("Tokens skipped: ");
  do {
  	t = getNextToken();
  	System.out.print(t + " ");
  	for(int a : kinds){
  		if((a == t.kind) | (t.kind == EOF))
  			exit = true;
  	}
  } while (!exit);
  System.out.print("\n\n");
  return t.kind;
}

JAVACODE
void incErrorCounter(){
	if(yal2jvm.error_counter++ == 10){
		System.out.println("Too many errors found!");
		System.exit(1);
	}
}

JAVACODE
SymbolTable generateSymbolTable(Node root) {

	SymbolTable symbolTable = new SymbolTable( (String)((SimpleNode) root).jjtGetValue());
	int numChildren = root.jjtGetNumChildren();

	for(int i = 0; i < numChildren; i++) {

		SimpleNode node = (SimpleNode) root.jjtGetChild(i);
		int nodeType = node.getId();

		switch (nodeType) {
			case JJTDECLARATION:
				
				symbolTable.addGlobalDeclaration((String)node.jjtGetValue(),node.getDataType());

				break;

			case JJTFUNCTION:

				String functionName = (String) node.jjtGetValue();
				String returnVariableName = (String) node.jjtGetSecValue();
				SymbolTable.Signature signature = new SymbolTable.Signature(functionName);
				SymbolTable.Function function = new SymbolTable.Function(signature);
				
				/**
				 * verificar se tem argumentos ou apenas statements
				 */

				Node argumentList;
				Node statementList;

				int functionChildrenNum = node.jjtGetNumChildren();
				statementList = node.jjtGetChild(0);

				// System.out.println("Function Name: " + signature.functionName);

				if(functionChildrenNum == 2) {

					argumentList = statementList;
					statementList = node.jjtGetChild(1);
					updateSymbolTableFunctionArguments(argumentList, function);


				}

				updateSymbolTableFunctionStatements(statementList,function);
				







				//add function
				symbolTable.addFunction(function);
				break;

			default:
				break;
		}
	}

	return symbolTable;


}

JAVACODE
void generateJavaBytecodes(Node root) throws IOException {

	String fileName = ((SimpleNode) root).jjtGetValue() + ".j";
	File jFile = new File(fileName);
	FileOutputStream jFileOS = new FileOutputStream(jFile);
	PrintWriter writer = new PrintWriter(jFileOS);

	moduleJavaBytecodes(root, writer);
}

JAVACODE
void moduleJavaBytecodes(Node root, PrintWriter writer){

	System.out.println(root);

	writer.println(".class public " + ((SimpleNode) root).jjtGetValue());
	writer.println(".super java/lang/Object\n");

	int numChildren = root.jjtGetNumChildren();

	for(int i = 0; i < numChildren; i++) {

		SimpleNode node = (SimpleNode) root.jjtGetChild(i);

		int nodeType = node.getId();

		switch (nodeType) {
			case JJTFUNCTION:

			functionJavaBytecodes(node, writer);


			default:
				break;
		}
	}	
	
	writer.close();

}

JAVACODE
public void functionJavaBytecodes(Node functionNode, PrintWriter writer){


    // locals nº de argumentos da funcao + declaraçoes locais
	// stack nº max entre 2, nº de args das fucntions Calls
	
	String functionName = (String) ((SimpleNode) functionNode).jjtGetValue();

	writer.print(".method public static " + functionName + "(");

	Node statementList;

	// Argmunts
	if (functionName.equals("main")) writer.println("[Ljava/lang/String;");
	else{
		
		
		Node argumentList;
		statementList = functionNode.jjtGetChild(0);

		if(functionNode.jjtGetNumChildren() == 2) {

			argumentList = statementList;
			statementList = functionNode.jjtGetChild(1);

			int numArguments = argumentList.jjtGetNumChildren();
			
				for(int i = 0; i < numArguments; i++) {
			
					SimpleNode argument = (SimpleNode) argumentList.jjtGetChild(i);
					
					String argumentName = (String)argument.jjtGetValue();
					SimpleNode.Type argumentDataType = argument.getDataType();
					
					writer.print(typeToStr(argumentDataType));
				}

		}
	}

	writer.println(")");

	// 
}

JAVACODE
String typeToStr(SimpleNode.Type type) {
	switch (type) {
	case INT:
		return "I";
	case ARRAY_INT:
		return "[I";
	case VOID:
		return "V";
	case STRING:
		return "Ljava/lang/String;";
	default:
		return "";
	}
}

JAVACODE
void updateSymbolTableFunctionArguments(Node argumentList, SymbolTable.Function function) {

	int numArguments = argumentList.jjtGetNumChildren();

	for(int i = 0; i < numArguments; i++) {

		SimpleNode argument = (SimpleNode) argumentList.jjtGetChild(i);

		//apenas uma verificação redundante se é do tipo elemento
		if(argument.getId() != JJTELEMENT) {

			System.out.println("Argument not of ELEMENT type, check why.");
			continue;
		}
		
		String argumentName = (String)argument.jjtGetValue();
		SimpleNode.Type argumentDataType = argument.getDataType();
		function.signature.addArgumentType(argumentName,argumentDataType);

	}

}

JAVACODE 
void updateSymbolTableFunctionStatements(Node statementList, SymbolTable.Function function) {

	int numStatements = statementList.jjtGetNumChildren();

	for(int i = 0; i < numStatements; i++) {

		SimpleNode node = (SimpleNode) statementList.jjtGetChild(i).jjtGetChild(0);

		SimpleNode lfs = (SimpleNode)node.jjtGetChild(0);

		switch (node.getId()) {

			
			
			case JJTASSIGN:

			

				if(node.getDataType() != null) {

					


					function.addLocalDeclaration((String)lfs.jjtGetValue(),node.getDataType());


				}
				else {



				}

				break;
		
			default:
				break;
		}

	}



}