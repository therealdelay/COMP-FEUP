options{

	MULTI=true;
}

PARSER_BEGIN(yal2jvm)



import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.io.IOException;
import java.util.*;

public class yal2jvm {
	public static int error_counter = 0;
	private static SimpleNode astRoot = null;
	public static void main(String args[]) throws ParseException, IOException {
		InputStream f = null;

		try {
			f = new FileInputStream("../yalExamples/" + args[0]);
		}catch(FileNotFoundException e) {
			System.out.println(e.getMessage());
		}

		//System.out.println("File: " + args[0]);

		yal2jvm parser = new yal2jvm(f);

		astRoot = parser.Module();

		System.out.print("Error count: " + error_counter + "\n\n");
		
		// System.out.println("AST:");
		// astRoot.dump("");

		// buildSymbolTable(astRoot);

		SymbolTable symbolTable = generateSymbolTable(astRoot);
		// generateJavaBytecodes(astRoot, symbolTable);
		// System.out.println(symbolTable);
		
		// updateNullTypesFunctionCalls(symbolTable);

		System.out.println(symbolTable);

		System.out.print("\n\n\n");
	}
}

PARSER_END(yal2jvm)

SKIP : {
	" "
	| "\t"
	| "\n"
	| "\r"
	| <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
	| <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
}

/* reserved words */
TOKEN : {
	<RELA_OP: ">" | "<" | "<=" | ">=" | "==" | "!=">
	| <ADDSUB_OP: "+" | "-">
	| <ARITH_OP: "*" | "/" | "<<" | ">>" | ">>>">
	| <BITWISE_OP: "&" | "|" | "^">
	| <NOT_OP: "!">
	| <WHILE: "while">
	| <IF: "if">
	| <ELSE: "else">
	| <ASSIGN: "=">
	| <ASPA: "\"">
	| <LPAR: "(">
	| <RPAR: ")">
	| <VIRG: ",">
	| <PVIRG: ";">
	| <LCHAVETA: "{">
	| <RCHAVETA: "}">
	| <FUNCTION: "function">
	| <MODULE: "module">
	| <SIZE: "size">
}

TOKEN : {
	<INTEGER: (<DIGIT>)+>
	| <ID: <LETTER> (<LETTER> | <DIGIT>)*>
	| <#LETTER: ["$","A"-"Z","_","a"-"z"]>
	| <#DIGIT: ["0"-"9"]>
	| <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\"">
}

SimpleNode Module() : {Token t;}{
	try{
		<MODULE> t=<ID>{jjtThis.jjtSetValue(t.image);} <LCHAVETA> (LOOKAHEAD(3) Declaration())* (Function())* <RCHAVETA>
	}
	catch (ParseException e) {
			System.out.println("EXCEPTION IN MODULE " + e.toString());
			incErrorCounter();
			int[] kinds = {RCHAVETA, EOF};
			error_skipto(kinds);
	}
	{return jjtThis;}
}

void Declaration() : {Token t, t2;}{

	t=<ID>{jjtThis.jjtSetValue(t.image);} ["[" "]" {jjtThis.jjtSetArrayType();}]
	[
		<ASSIGN>
		try{
			(("[" ArraySize() "]") {jjtThis.jjtSetArrayType();} | [<ADDSUB_OP>] t2=<INTEGER>{jjtThis.jjtSetIntType();})
		}
		catch (ParseException e) {
			System.out.println("EXCEPTION IN DECLARATION " + e.toString());
			incErrorCounter();
			int[] kinds = {PVIRG};
			error_skipto(kinds);
		}
	]
	try{
		<PVIRG>
	}
	catch(ParseException e){
		System.out.println("EXCEPTION IN DECLARATION " + e.toString());
		incErrorCounter();
		int[] kinds = {PVIRG};
		error_skipto(kinds);
	}
}


void Function() : {Token t1, t2;}{

	try{
		<FUNCTION>{jjtThis.jjtSetType(SimpleNode.Type.VOID);} [LOOKAHEAD(2) t2=<ID>{jjtThis.jjtSetSecValue(t2.image);jjtThis.jjtSetIntType();} ["[" "]"{jjtThis.jjtSetArrayType();}] <ASSIGN>] t1=<ID>{jjtThis.jjtSetValue(t1.image);}
	}
	catch (ParseException e) {
			System.out.println("EXCEPTION IN FUNCTION " + e.toString());
			incErrorCounter();
			int[] kinds = {PVIRG, LCHAVETA, LPAR, ID};
			error_skipto(kinds);
	}

	try{
		<LPAR> [Varlist()] <RPAR>
	}
	catch (ParseException e) {
			System.out.println("EXCEPTION IN FUNCTION " + e.toString());
			incErrorCounter();
			int[] kinds = {RPAR};
			error_skipto(kinds);
	}
	<LCHAVETA> Stmtlst() <RCHAVETA>
}

void Varlist() : {}{
	(Element()) ( <VIRG> Element() )*
}

void ArrayElement() : {Token t;}
{
	t=<ID>{jjtThis.jjtSetValue(t.image);} "[" "]"
}

void Element() : {Token t;}
{
	t=<ID>{jjtThis.jjtSetValue(t.image); jjtThis.jjtSetIntType();} ["[" "]"{jjtThis.jjtSetArrayType();}]
}

void ScalarElement() : {Token t;}
{
	t=<ID>{jjtThis.jjtSetValue(t.image);}
}

void Stmtlst() : {}
{
	( Stmt() )*
}

void SpecialStmtlst() #void : {}
{
	Stmtlst() <RCHAVETA>
}

void Stmt() : {}
{
	try{
		If() | While() | LOOKAHEAD(3) Assign() | Callstmt()
	}
	catch (ParseException e) {
		System.out.println("EXCEPTION IN STMT " + e.toString());
		incErrorCounter();
		int[] kinds = {RPAR, PVIRG, LCHAVETA};
		error_skipto(kinds);
	}
}

void Assign() : {}
{
	Lhs() <ASSIGN>
	try{
		Rhs() <PVIRG>
	}
	catch (ParseException e) {
		System.out.println("EXCEPTION IN ASSIGN " + e.toString());
		incErrorCounter();
		int[] kinds = {PVIRG};
		error_skipto(kinds);
	}
}

void Lhs() : {Token t;}
{
	t=<ID>{jjtThis.jjtSetValue(t.image);} (("[" Index() "]")|["." <SIZE>])
}

void Rhs() : {Token t;}
{
	(Term() [(t=<ARITH_OP>| t=<BITWISE_OP> | t=<ADDSUB_OP>){jjtThis.jjtSetValue(t.image);}  Term()]) | "[" ArraySize(){((SimpleNode)jjtThis).jjtSetArrayType();} "]"
}

void ArraySize() : {}
{
	ScalarAccess() | <INTEGER>
}

void Term() : {Token t1,t2,t3,t4;}
{
[t1=<ADDSUB_OP>{jjtThis.jjtSetSecValue(t1.image);}] (t2=<INTEGER>{jjtThis.jjtSetValue(t2.image);jjtThis.jjtSetIntType();} | LOOKAHEAD(3) Call() | (t3=<ID>{jjtThis.jjtSetValue(t3.image);jjtThis.jjtSetAssignId(t3.image);} (("[" Index() "]")|(["." t4=<SIZE>{jjtThis.jjtSetValue(t4.image);}]))))
}

void Exprtest() : {}
{
	try{
		<LPAR> Lhs() <RELA_OP> Rhs() <RPAR>
	}
	catch (ParseException e) {
		System.out.println("EXCEPTION IN EXPRTEST " + e.toString());
		incErrorCounter();
		int[] kinds = {RPAR};
		error_skipto(kinds);
	}
}

void While() : {}
{
	<WHILE> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA>
}

void If() : {}
{
	<IF> Exprtest() <LCHAVETA> Stmtlst() <RCHAVETA>

	try{
		[<ELSE> <LCHAVETA> Stmtlst() <RCHAVETA>]
	}
	catch (ParseException e) {
		System.out.println("EXCEPTION IN ELSE " + e.toString());
		incErrorCounter();
		int[] kinds = {PVIRG};
		error_skipto(kinds);
	}
}

void Call() : {Token t1, t2;}
{
	t1=<ID>{jjtThis.jjtSetValue(t1.image);jjtThis.jjtSetAssignId(t1.image);} ["." t2=<ID>{jjtThis.jjtSetSecValue(t2.image);jjtThis.jjtSetAssignId(t2.image);jjtThis.setAssignIdModule(t1.image);}] <LPAR>

	try{
		[ArgumentList()] <RPAR>
	}
	catch (ParseException e) {
		System.out.println("EXCEPTION IN CALL " + e.toString());
		incErrorCounter();
		int[] kinds = {RCHAVETA, LCHAVETA, RPAR};
		int ret = error_skipto(kinds);
		if(ret == LCHAVETA){
			SpecialStmtlst();
		}
	}
}

void Callstmt() #Call : {Token t1, t2;}
{
	t1=<ID>{jjtThis.jjtSetValue(t1.image);} ["." t2=<ID>{jjtThis.jjtSetSecValue(t2.image);}] <LPAR>

	try{
		[ArgumentList()] <RPAR> <PVIRG>
	}
	catch (ParseException e) {
		System.out.println("EXCEPTION IN CALL " + e.toString());
		incErrorCounter();
		int[] kinds = {PVIRG, RCHAVETA, LCHAVETA};
		int ret = error_skipto(kinds);
		if(ret == LCHAVETA){
			SpecialStmtlst();
		}
	}
}

void ArgumentList() : {}
{
	Argument() ( <VIRG> Argument() )*
}

void Argument() : {Token t;}
{
	( t=<ID>{jjtThis.jjtSetValue(t.image);jjtThis.addAssignFunctionParameter(t.image,null);} | t=<STRING>{jjtThis.jjtSetValue(t.image);jjtThis.addAssignFunctionParameter(null,SimpleNode.Type.STRING);} | t=<INTEGER>{jjtThis.jjtSetValue(t.image); jjtThis.addAssignFunctionParameter(null,SimpleNode.Type.INT);})
}

void ArrayAccess() : {Token t;}
{
	t=<ID>{jjtThis.jjtSetValue(t.image);} "[" Index() "]"
}

void ScalarAccess() : {Token t, t1;}
{
	t=<ID>{jjtThis.jjtSetValue(t.image);} ["." t1=<SIZE>{jjtThis.jjtSetSecValue(t1.image);}]
}

void Index() : {Token t;}
{
	t=<ID>{jjtThis.jjtSetValue(t.image);} | t=<INTEGER>{jjtThis.jjtSetValue(t.image);}
}

JAVACODE
int error_skipto(int[] kinds) #void {
  Token t;
  boolean exit = false;
  System.out.print("Tokens skipped: ");
  do {
  	t = getNextToken();
  	System.out.print(t + " ");
  	for(int a : kinds){
  		if((a == t.kind) | (t.kind == EOF))
  			exit = true;
  	}
  } while (!exit);
  System.out.print("\n\n");
  return t.kind;
}

JAVACODE
void incErrorCounter(){
	if(yal2jvm.error_counter++ == 10){
		System.out.println("Too many errors found!");
		System.exit(1);
	}
}


JAVACODE
void generateJavaBytecodes(Node root, SymbolTable symbolTable) throws IOException {

	String fileName = ((SimpleNode) root).jjtGetValue() + ".j";
	File jFile = new File(fileName);
	FileOutputStream jFileOS = new FileOutputStream(jFile);
	PrintWriter writer = new PrintWriter(jFileOS);

	moduleJavaBytecodes(root, writer, symbolTable);
}

JAVACODE
void moduleJavaBytecodes(Node root, PrintWriter writer, SymbolTable symbolTable){

	writer.println(".class public " + ((SimpleNode) root).jjtGetValue());
	writer.println(".super java/lang/Object\n");

	int numChildren = root.jjtGetNumChildren();

	for(int i = 0; i < numChildren; i++) {

		SimpleNode node = (SimpleNode) root.jjtGetChild(i);

		int nodeType = node.getId();

		switch (nodeType) {
			case JJTFUNCTION:

			functionJavaBytecodes(node, writer, symbolTable);


			default:
				break;
		}
	}	
	
	writer.close();

}

JAVACODE
public void functionJavaBytecodes(SimpleNode functionNode, PrintWriter writer, SymbolTable symbolTable){


    // locals nº de argumentos da funcao + declaraçoes locais
	// stack nº max entre 2, nº de args das fucntions Calls
	
	String functionName = (String) functionNode.jjtGetValue();
	ArrayList<SimpleNode.Type> argumentTypes = new ArrayList();

	writer.print(".method public static ");

	Node statementList = functionNode.jjtGetChild(0);
	Node argumentList;

	// Locals stack
	// calculateLimitLocals(function);
	// calculateLimitStack(function);
	int limitLocals = 10, limitStack = 10;

	ArrayList<String> register_variables = new ArrayList();
	for(int i=0; i<limitLocals; i++) register_variables.add(null);

	// Arguments
	if(functionNode.jjtGetNumChildren() == 2) {

		argumentList = statementList;
		statementList = functionNode.jjtGetChild(1);

		int numArguments = argumentList.jjtGetNumChildren();
		
		for(int i = 0; i < numArguments; i++) {
	
			SimpleNode argument = (SimpleNode) argumentList.jjtGetChild(i);
			
			String argumentName = (String)argument.jjtGetValue();
			register_variables.set(register_variables.indexOf(null), argumentName);
		
			SimpleNode.Type argumentDataType = argument.getDataType();
			argumentTypes.add(argumentDataType);
		}

	}

	SymbolTable.Signature sign = new SymbolTable.Signature(argumentTypes, functionName);
	writer.println(functionToBytecodes(symbolTable.functions.get(sign)));

	writer.println(".limit locals " + limitLocals);
	writer.println(".limit stack " + limitStack);

	// StmtList
	int numStatements = statementList.jjtGetNumChildren();
	for(int i = 0; i < numStatements; i++) {
		
		SimpleNode statement = (SimpleNode) statementList.jjtGetChild(i);
		
		statementJavaBytecodes(statement, writer, register_variables, symbolTable, sign);
	}
	
}

JAVACODE
public void statementJavaBytecodes(SimpleNode statementNode, PrintWriter writer, ArrayList<String> register_variables, SymbolTable symbolTable, SymbolTable.Signature sign){

	SimpleNode statementChild = (SimpleNode) statementNode.jjtGetChild(0);
	switch (statementChild.getId()) {
		case yal2jvmTreeConstants.JJTASSIGN:
			
			int register_index = register_variables.indexOf(null);
			register_variables.set(register_index, (String) ((SimpleNode) statementChild.jjtGetChild(0)).jjtGetValue());
			String lhsBytecode = "istore_" + register_index;

			SimpleNode rhsNode = (SimpleNode) statementChild.jjtGetChild(1);

			rhsJavaBytecodes(rhsNode, writer, register_variables, symbolTable, sign);

			writer.println(lhsBytecode);
			break;
	
		default:
			break;
	}
}

JAVACODE
public void rhsJavaBytecodes(SimpleNode rhsNode, PrintWriter writer, ArrayList<String> register_variables, SymbolTable symbolTable, SymbolTable.Signature sign){
	SimpleNode rhs1stChild = (SimpleNode) rhsNode.jjtGetChild(0);

	switch (rhs1stChild.getId()) {
		case yal2jvmTreeConstants.JJTTERM:
			
			termJavaBytecodes(rhs1stChild, writer, register_variables, symbolTable, sign);
			break;
	
		default:
		// ARRAY SIZE DEF
			break;
	}

	if(rhsNode.jjtGetNumChildren() == 2){
				
		SimpleNode term2 = (SimpleNode) rhsNode.jjtGetChild(1);
		termJavaBytecodes(term2, writer, register_variables, symbolTable, sign);

		switch ((String)rhsNode.jjtGetValue()) {
			case "*":
				writer.println("imul");
				break;
			// TODO: /, + , -, ...
			default:
				break;
		}
	}
}

JAVACODE
public void termJavaBytecodes(SimpleNode termNode, PrintWriter writer, ArrayList<String> register_variables, SymbolTable symbolTable, SymbolTable.Signature sign){

	if(termNode.jjtGetNumChildren() == 0){
		if(termNode.getDataType() == SimpleNode.Type.INT){

			if((Integer) termNode.jjtGetValue()>5)
				writer.println("bipush " + (String) termNode.jjtGetValue());
			else
				writer.println("iconst_" + (String) termNode.jjtGetValue());
		}
		else{ // ID
			int rIndex = register_variables.indexOf((String) termNode.jjtGetValue());
			writer.println("iload_" + rIndex);
		}
	}
	else{ //function call
		SimpleNode callNode = (SimpleNode) termNode.jjtGetChild(0);

		String functionName = (String) callNode.jjtGetValue();

		SimpleNode argsListNode = (SimpleNode) callNode.jjtGetChild(0);

		ArrayList<SimpleNode.Type> argumentTypes = new ArrayList();

		ArrayList<SymbolTable.Pair<String, SimpleNode.Type>> assignFunctionParameters = callNode.getAssignFunctionParameters();
		for (int i = 0; i < argsListNode.jjtGetNumChildren(); i++) {
			SimpleNode argNode = (SimpleNode) argsListNode.jjtGetChild(i);

			System.out.println("functionName: " + functionName);
			System.out.println("assignFunctionParameters size: " + assignFunctionParameters.size());
			for (SymbolTable.Pair<String, SimpleNode.Type> pair : assignFunctionParameters) {
				System.out.println("assignFunctionParameters content: [" + pair.key + ", " + pair.value + "]");
			}
			String argName = assignFunctionParameters.get(i).key;
			if(argName != null){

				SimpleNode.Type type = symbolTable.globalDeclarations.get(argName);

				if(type == null){
					SymbolTable.Function function = symbolTable.functions.get(sign);
					type = function.localDeclarations.get(argName);
				}
				argumentTypes.add(type);
				int rIndex = register_variables.indexOf((String) argNode.jjtGetValue());
				writer.println("iload_LEO" + rIndex);
			}
			else{
				argumentTypes.add(assignFunctionParameters.get(i).value);
				writer.println(loadIntegerToBytecodes(Integer.parseInt((String)((SimpleNode)argNode).jjtGetValue())));
			}
		}

		SymbolTable.Signature funcCallSign = new SymbolTable.Signature(argumentTypes, functionName);

	}
}


JAVACODE
String typeToBytecodes(SimpleNode.Type type) {
	switch (type) {
	case INT:
		return "I";
	case ARRAY_INT:
		return "[I";
	case VOID:
		return "V";
	case STRING:
		return "Ljava/lang/String;";
	default:
		return "";
	}
}

JAVACODE
String functionToBytecodes(SymbolTable.Function function){
	String result = function.signature.functionName + "(";
	
	if (function.signature.functionName.equals("main")) result +=  "[Ljava/lang/String;";
	else{
		ArrayList<SimpleNode.Type> argumentTypes = function.signature.argumentTypes;
		for (SimpleNode.Type type : argumentTypes) {
			result += typeToBytecodes(type);
		}
	}

	result += ")";

	// Return type
	result += typeToBytecodes(function.returnType);

	return result;
}

JAVACODE 
String loadIntegerToBytecodes(Integer value){

	if(value > 5) 
		return "bipush " + value;
	else 
		return "iconst_" + value;	
}

JAVACODE
SymbolTable generateSymbolTable(Node root) {

	SymbolTable symbolTable = new SymbolTable( (String)((SimpleNode) root).jjtGetValue());
	int numChildren = root.jjtGetNumChildren();

	ArrayList<SymbolTable.Function> allFunctions = new ArrayList();
	ArrayList<Node> allStatementsListNodes = new ArrayList();
	ArrayList<Node> allFunctionsNodes = new ArrayList();

	for(int i = 0; i < numChildren; i++) {

		SimpleNode node = (SimpleNode) root.jjtGetChild(i);
		int nodeType = node.getId();

		switch (nodeType) {
			case JJTDECLARATION:

				symbolTable.addGlobalDeclaration((String)node.jjtGetValue(),node.getDataType());
				break;

			case JJTFUNCTION:

				String functionName = (String) node.jjtGetValue();
				SimpleNode.Type returnType = node.getDataType();
				SymbolTable.Signature signature = new SymbolTable.Signature(functionName);
				SymbolTable.Function function = new SymbolTable.Function(signature,returnType);

				/**
				 * verificar se tem argumentos ou apenas statements
				 */

				Node argumentList;
				Node statementList;

				int functionChildrenNum = node.jjtGetNumChildren();
				statementList = node.jjtGetChild(0);

				// System.out.println("Function Name: " + signature.functionName);

				if(functionChildrenNum == 2) {

					argumentList = statementList;
					statementList = node.jjtGetChild(1);
					updateSymbolTableFunctionArguments(argumentList, function);


				}

				allFunctions.add(function);
				allStatementsListNodes.add(statementList);
				allFunctionsNodes.add(node);

				// updateSymbolTableFunctionStatements(statementList,function,symbolTable);
				// updateSymbolTableFunctionFunctionCalls(node, function);

				//add function
				symbolTable.addFunction(function);

				break;

			default:
				break;
		}
	}

	for(int i = 0; i < allFunctions.size(); i++) {

		// updateSymbolTableFunctionStatements(statementList,function,symbolTable);
		updateSymbolTableFunctionFunctionCalls(allFunctionsNodes.get(i), allFunctions.get(i), symbolTable);

	}

	return symbolTable;


}

JAVACODE
void updateSymbolTableFunctionArguments(Node argumentList, SymbolTable.Function function) {

	int numArguments = argumentList.jjtGetNumChildren();

	for(int i = 0; i < numArguments; i++) {

		SimpleNode argument = (SimpleNode) argumentList.jjtGetChild(i);

		//apenas uma verificação redundante se é do tipo elemento
		if(argument.getId() != JJTELEMENT) {

			System.out.println("Argument not of ELEMENT type, check why.");
			continue;
		}

		String argumentName = (String)argument.jjtGetValue();
		SimpleNode.Type argumentDataType = argument.getDataType();
		function.signature.addArgumentType(argumentName,argumentDataType);

	}

}

JAVACODE
void updateSymbolTableFunctionStatements(Node statementList, SymbolTable.Function function, SymbolTable symbolTable) {

	int numStatements = statementList.jjtGetNumChildren();

	for(int i = 0; i < numStatements; i++) {

		SimpleNode node = (SimpleNode) statementList.jjtGetChild(i).jjtGetChild(0);

		SimpleNode lhs = (SimpleNode)node.jjtGetChild(0);

		String variableName = (String) lhs.jjtGetValue();

		switch (node.getId()) {

			case JJTASSIGN:

				if(node.getDataType() != null) {

					if(symbolTable.globalDeclarations.containsKey(variableName)) {

						if(symbolTable.addGlobalDeclaration(variableName,node.getDataType()) == false) {
							System.out.println("Repeated global variable found in function");
						}

					}

					else
						function.addLocalDeclaration(variableName,node.getDataType(),null,null,null);

				}
				else {

					if(node.getAssignId() != null) {

						String previousVariable = node.getAssignId();
						SimpleNode.Type type = function.localDeclarations.get(previousVariable);

						if(type == null)
							type = symbolTable.globalDeclarations.get(previousVariable);

						String localVariable = null;
						SymbolTable.Signature signature = null;

						SimpleNode rhs = (SimpleNode) node.jjtGetChild(1);

						if(((SimpleNode)rhs.jjtGetChild(0)).getId() == JJTTERM) {

							SimpleNode term = (SimpleNode) rhs.jjtGetChild(0);

							if(term.jjtGetNumChildren() > 0 && ((SimpleNode) term.jjtGetChild(0)).getId() == JJTCALL) {

								SimpleNode call = (SimpleNode) term.jjtGetChild(0);

								signature = new SymbolTable.Signature(call.getAssignId(),call.getAssignFunctionParameters());

							}

							else
								localVariable = (String) term.jjtGetValue();


						}

						function.addLocalDeclaration(variableName,type, localVariable, signature, symbolTable.globalDeclarations);
							

					}

				}

				break;

			case JJTWHILE:
			case JJTIF:

				SimpleNode statementListIfWhile = (SimpleNode) node.jjtGetChild(1);
				updateSymbolTableFunctionStatements(statementListIfWhile, function, symbolTable);

				break;

			default:

				break;
		}

	}
}


JAVACODE
void updateSymbolTableFunctionFunctionCalls(Node node, SymbolTable.Function function, SymbolTable symbolTable) {

	SimpleNode currentNode = (SimpleNode) node;

	if(currentNode.getId() == JJTCALL) {

		String functionName = (String)currentNode.jjtGetValue();
		String moduleName = null;

		if(currentNode.jjtGetSecValue() != null) {
			moduleName = functionName;
			functionName = (String) currentNode.jjtGetSecValue();
		}

		ArrayList<SymbolTable.Pair<String,SimpleNode.Type>> functionCallParameters = currentNode.assignFunctionParameters;

		SymbolTable.FunctionCall functionCall = symbolTable.checkGoodFunctionCall(functionName, moduleName, functionCallParameters, function);

		function.addFunctionCall(functionCall);

	}

	else {

		for(int i = 0; i < currentNode.jjtGetNumChildren(); i++) {

			updateSymbolTableFunctionFunctionCalls(currentNode.jjtGetChild(i),function, symbolTable);

		}



	}



}


JAVACODE
void updateNullTypesFunctionCalls(SymbolTable symbolTable) {

	HashMap<SymbolTable.Signature,SymbolTable.Function> functions = symbolTable.functions;

	for(SymbolTable.Signature signature: functions.keySet()) {

		SymbolTable.Function function = functions.get(signature);

		ArrayList<SymbolTable.Pair<String,SymbolTable.Signature>> nullDeclarationsFunctionCalls = function.nullDeclarationsFunctionCalls;

		for(SymbolTable.Pair<String,SymbolTable.Signature> nullDeclarationsFunctionCall : nullDeclarationsFunctionCalls) {
			
			SymbolTable.Signature functionCallSignature = nullDeclarationsFunctionCall.value;

			int argumentsSize = functionCallSignature.arguments.size();

			ArrayList<SimpleNode.Type> argumentTypesFunctionCall = new ArrayList<SimpleNode.Type>(argumentsSize);

			for(int i = 0; i < argumentsSize; i++) {

				argumentTypesFunctionCall.add(SimpleNode.Type.INT);

			}

			for(int i = 0; i < argumentsSize; i++) {

				if(functionCallSignature.argumentTypes.get(i) != null) {
					argumentTypesFunctionCall.set(i, functionCallSignature.argumentTypes.get(i));
				}
				else {
					
					String variable = functionCallSignature.arguments.get(i);

					SimpleNode.Type type = symbolTable.globalDeclarations.get(variable);

					if(type == null)
						type = function.localDeclarations.get(variable);

					argumentTypesFunctionCall.set(i, type);

					if(type == null) {
						
						System.out.println("Variable " + variable + " not initialized " + "in " + functionCallSignature.functionName + " call on function " + function.signature.functionName);
						continue;
					}

				}

			}

			SymbolTable.Signature signatureFunctionCall = new SymbolTable.Signature(argumentTypesFunctionCall,functionCallSignature.functionName);

			SymbolTable.Function functionFunctionCall = symbolTable.functions.get(signatureFunctionCall);

			if(functionFunctionCall == null) {

				System.out.print("Function " + signatureFunctionCall.functionName + "("); 
				
				for(int i = 0; i < signatureFunctionCall.argumentTypes.size(); i++) {
					System.out.print(signatureFunctionCall.argumentTypes.get(i));

					if(i < signatureFunctionCall.argumentTypes.size()-1)
						System.out.print(", ");

				}

				System.out.println(") does not exist");
				continue;

			}

			//Ver se já era global e se o tipo é o mesmo, se não for, meter nas repetidas, se ainda não tiver tipo, atribuir o do return
			//da função

			String nullFunctionCallAssignVariable = nullDeclarationsFunctionCall.key;
			SimpleNode.Type returnType = functionFunctionCall.returnType;

			if(symbolTable.globalDeclarations.containsKey(nullFunctionCallAssignVariable)) {

				SimpleNode.Type currentType = symbolTable.globalDeclarations.get(nullFunctionCallAssignVariable);

				symbolTable.addGlobalDeclaration(nullFunctionCallAssignVariable, returnType);
				function.localDeclarations.remove(nullFunctionCallAssignVariable);

			}

			else {

				SimpleNode.Type nullType = function.localDeclarations.get(nullFunctionCallAssignVariable);
				function.localDeclarations.put(nullFunctionCallAssignVariable, returnType);

			}

		}

	}

}